<?php

declare( strict_types = 1 );

namespace WMDE\Fundraising\DonationContext\Tests\Integration\DataAccess;

use Doctrine\ORM\EntityManager;
use Doctrine\ORM\Exception\ORMException;
use PHPUnit\Framework\Attributes\CoversClass;
use PHPUnit\Framework\TestCase;
use WMDE\Fundraising\DonationContext\DataAccess\DoctrineDonationExistsChecker;
use WMDE\Fundraising\DonationContext\DataAccess\DoctrineDonationRepository;
use WMDE\Fundraising\DonationContext\DataAccess\DoctrineEntities\Donation as DoctrineDonation;
use WMDE\Fundraising\DonationContext\DataAccess\DonorFactory;
use WMDE\Fundraising\DonationContext\DataAccess\DonorFieldMapper;
use WMDE\Fundraising\DonationContext\DataAccess\LegacyConverters\DataBlobScrubber;
use WMDE\Fundraising\DonationContext\DataAccess\LegacyConverters\DomainToLegacyConverter;
use WMDE\Fundraising\DonationContext\DataAccess\LegacyConverters\LegacyToDomainConverter;
use WMDE\Fundraising\DonationContext\DataAccess\ModerationReasonRepository;
use WMDE\Fundraising\DonationContext\Domain\Model\ModerationIdentifier;
use WMDE\Fundraising\DonationContext\Domain\Model\ModerationReason;
use WMDE\Fundraising\DonationContext\Domain\Repositories\GetDonationException;
use WMDE\Fundraising\DonationContext\Domain\Repositories\StoreDonationException;
use WMDE\Fundraising\DonationContext\Tests\Data\ValidDoctrineDonation;
use WMDE\Fundraising\DonationContext\Tests\Data\ValidDonation;
use WMDE\Fundraising\DonationContext\Tests\Data\ValidPayments;
use WMDE\Fundraising\DonationContext\Tests\Fixtures\FailingDonationExistsChecker;
use WMDE\Fundraising\DonationContext\Tests\Fixtures\SucceedingDonationExistsChecker;
use WMDE\Fundraising\DonationContext\Tests\TestEnvironment;
use WMDE\Fundraising\PaymentContext\Domain\Model\LegacyPaymentData;
use WMDE\Fundraising\PaymentContext\UseCases\GetPayment\GetPaymentUseCase;

#[CoversClass( DoctrineDonationRepository::class )]
#[CoversClass( DonorFieldMapper::class )]
#[CoversClass( DonorFactory::class )]
#[CoversClass( DoctrineDonation::class )]
#[CoversClass( DomainToLegacyConverter::class )]
#[CoversClass( LegacyToDomainConverter::class )]
#[CoversClass( DataBlobScrubber::class )]
class DoctrineDonationRepositoryTest extends TestCase {

	private const ID_OF_DONATION_NOT_IN_DB = 35505;

	private EntityManager $entityManager;
	private ModerationReasonRepository $moderationRepository;

	private LegacyPaymentData $legacyPaymentData;

	public function setUp(): void {
		$factory = TestEnvironment::newInstance()->getFactory();
		$this->entityManager = $factory->getEntityManager();
		$this->moderationRepository = new ModerationReasonRepository( $this->entityManager );
		parent::setUp();
		$this->legacyPaymentData = $this->createDefaultLegacyData();
	}

	public function testValidDonationGetPersisted(): void {
		$donation = ValidDonation::newDirectDebitDonation();
		$this->legacyPaymentData = ValidPayments::newDirectDebitLegacyData();
		$this->newRepository()->storeDonation( $donation );

		$expectedDoctrineEntity = ValidDoctrineDonation::newDirectDebitDoctrineDonation();
		$expectedDoctrineEntity->setId( $donation->getId() );

		$this->assertDoctrineEntityIsInDatabase( $expectedDoctrineEntity );
	}

	private function newRepository(): DoctrineDonationRepository {
		return new DoctrineDonationRepository(
			$this->entityManager,
			new DoctrineDonationExistsChecker( $this->entityManager ),
			$this->makeGetPaymentUseCaseStub(),
			$this->moderationRepository
		);
	}

	private function assertDoctrineEntityIsInDatabase( DoctrineDonation $expected ): void {
		$this->assertNotNull( $expected->getId() );
		$actual = $this->getDoctrineDonationById( $expected->getId() );

		// creationTime is autogenerated when saving, so we check if it was autogenerated
		// and then modify our expected value (where it's null) to match the date, so the comparison succeeds
		$this->assertNotNull( $actual->getCreationTime() );
		$expected->setCreationTime( $actual->getCreationTime() );

		$this->assertEquals( $expected->getModerationReasons()->toArray(), $actual->getModerationReasons()->toArray() );
		$this->assertEquals( $expected->getDecodedData(), $actual->getDecodedData() );

		// reset the moderation reasons because doctrine sets the moderation reasons to a PersistedCollection instead of ArrayCollection
		// this way we can compare the objects
		/**
		 * @var ModerationReason[] $moderationReasons
		 */
		$moderationReasons = $expected->getModerationReasons()->toArray();
		$actual->setModerationReasons( ...$moderationReasons );
		$this->assertEquals( $expected, $actual );
	}

	private function getDoctrineDonationById( int $id ): DoctrineDonation {
		$donationRepo = $this->entityManager->getRepository( DoctrineDonation::class );
		$donation = $donationRepo->find( $id );
		$this->assertInstanceOf( DoctrineDonation::class, $donation );
		return $donation;
	}

	public function testWhenInsertFails_domainExceptionIsThrown(): void {
		$donation = ValidDonation::newDirectDebitDonation();

		$repository = new DoctrineDonationRepository(
			$this->newEntityManagerThatThrowsOnPersist(),
			new SucceedingDonationExistsChecker(),
			$this->makeGetPaymentUseCaseStub(),
			$this->moderationRepository
		);

		$this->expectException( StoreDonationException::class );
		$repository->storeDonation( $donation );
	}

	public function testNewDonationPersistenceRoundTrip(): void {
		$donation = ValidDonation::newDirectDebitDonation();

		$repository = $this->newRepository();

		$repository->storeDonation( $donation );
		// find() will retrieve a cached value, so we should clear the entity cache here
		$this->entityManager->clear();

		$this->assertEquals(
			$donation,
			$repository->getDonationById( $donation->getId() )
		);
	}

	public function testNewModeratedDonationPersistenceRoundTrip(): void {
		$donation = ValidDonation::newDirectDebitDonation();
		$donation->markForModeration( new ModerationReason( ModerationIdentifier::ADDRESS_CONTENT_VIOLATION ) );

		$repository = $this->newRepository();

		$repository->storeDonation( $donation );
		// find() will retrieve a cached value, so we should clear the entity cache here
		$this->entityManager->clear();

		$storedDonation = $repository->getDonationById( $donation->getId() );

		$this->assertNotNull( $storedDonation );
		$this->assertEquals(
			$donation->getModerationReasons(),
			$storedDonation->getModerationReasons()
		);
	}

	public function testScrubbedDonationPersistenceRoundTrip(): void {
		$donation = ValidDonation::newDirectDebitDonation();
		$donation->markAsExported( new \DateTimeImmutable( '2024-06-21 00:05:00' ) );
		$donation->scrubPersonalData();

		$repository = $this->newRepository();

		$repository->storeDonation( $donation );
		// find() will retrieve a cached value, so we should clear the entity cache here
		$this->entityManager->clear();

		$this->assertTrue( $donation->donorIsScrubbed() );
		$this->assertEquals(
			$donation,
			$repository->getDonationById( $donation->getId() )
		);
	}

	public function testWhenDonationAlreadyExists_persistingCausesUpdate(): void {
		$repository = $this->newRepository();

		$donation = ValidDonation::newDirectDebitDonation();
		$repository->storeDonation( $donation );

		// It is important a new instance is created here to test "detached entity" handling
		$newDonation = ValidDonation::newDirectDebitDonation( $donation->getId() );
		$newDonation->markForModeration( new ModerationReason( ModerationIdentifier::MANUALLY_FLAGGED_BY_ADMIN ) );
		$repository->storeDonation( $newDonation );

		$this->assertEquals( $newDonation, $repository->getDonationById( $donation->getId() ) );
	}

	public function testWhenDonationDoesNotExist_getDonationReturnsNull(): void {
		$repository = $this->newRepository();

		$this->assertNull( $repository->getDonationById( self::ID_OF_DONATION_NOT_IN_DB ) );
	}

	public function testWhenDoctrineThrowsException_domainExceptionIsThrown(): void {
		$repository = new DoctrineDonationRepository(
			$this->newEntityManagerThatThrowsOnFind(),
			new SucceedingDonationExistsChecker(),
			$this->makeGetPaymentUseCaseStub(),
			$this->moderationRepository
		);

		$this->expectException( GetDonationException::class );
		$repository->getDonationById( self::ID_OF_DONATION_NOT_IN_DB );
	}

	public function testGivenDonationUpdateWithoutDonorInformation_DonorNameStaysTheSame(): void {
		$donation = ValidDonation::newBookedPayPalDonation();
		$this->newRepository()->storeDonation( $donation );

		$anonymousDonation = ValidDonation::newBookedAnonymousPayPalDonationUpdate( $donation->getId() );
		$this->newRepository()->storeDonation( $anonymousDonation );

		$doctrineDonation = $this->getDoctrineDonationById( $donation->getId() );

		$this->assertSame( $donation->getDonor()->getName()->getFullName(), $doctrineDonation->getDonorFullName() );
	}

	public function testCommentGetPersistedAndRetrieved(): void {
		$donation = ValidDonation::newDirectDebitDonation();
		$donation->addComment( ValidDonation::newPublicComment() );

		$repository = $this->newRepository();
		$repository->storeDonation( $donation );

		$retrievedDonation = $repository->getDonationById( $donation->getId() );

		$this->assertEquals( $donation, $retrievedDonation );
	}

	public function testPersistingDonationWithoutCommentCausesCommentToBeCleared(): void {
		$this->legacyPaymentData = ValidPayments::newDirectDebitLegacyData();
		$donation = ValidDonation::newDirectDebitDonation();
		$donation->addComment( ValidDonation::newPublicComment() );

		$repository = $this->newRepository();
		$repository->storeDonation( $donation );

		$newDonation = ValidDonation::newDirectDebitDonation( $donation->getId() );

		$repository->storeDonation( $newDonation );

		$expectedDoctrineEntity = ValidDoctrineDonation::newDirectDebitDoctrineDonation();
		$expectedDoctrineEntity->setId( $donation->getId() );
		$expectedDoctrineEntity->setComment( '' );
		$expectedDoctrineEntity->setIsPublic( false );
		$expectedDoctrineEntity->setPublicRecord( '' );

		$this->assertDoctrineEntityIsInDatabase( $expectedDoctrineEntity );
	}

	public function testWhenUpdateFails_domainExceptionIsThrown(): void {
		$donation = ValidDonation::newDirectDebitDonation( 42 );

		$repository = new DoctrineDonationRepository(
			$this->newEntityManagerThatThrowsOnPersist(),
			new FailingDonationExistsChecker(),
			$this->makeGetPaymentUseCaseStub(),
			$this->moderationRepository
		);

		$this->expectException( StoreDonationException::class );
		$repository->storeDonation( $donation );
	}

	public function makeGetPaymentUseCaseStub(): GetPaymentUseCase {
		$stub = $this->createStub( GetPaymentUseCase::class );
		$stub->method( 'getLegacyPaymentDataObject' )->willReturn( $this->legacyPaymentData );
		return $stub;
	}

	private function createDefaultLegacyData(): LegacyPaymentData {
		// Bogus data
		return new LegacyPaymentData(
			999999,
			999,
			'PPL',
			[
				'paymentValue' => 'almostInfinite',
				'paid' => 'certainly'
			],
		);
	}

	public function testGivenTwoDonationsWithTheSameModerationReason_ReasonIsNotCreatedMultipleTimesButReused(): void {
		$donation1 = ValidDonation::newDirectDebitDonation();
		$donation1->markForModeration( new ModerationReason( ModerationIdentifier::ADDRESS_CONTENT_VIOLATION ) );
		$donation2 = ValidDonation::newDirectDebitDonation();
		$donation2->markForModeration( new ModerationReason( ModerationIdentifier::ADDRESS_CONTENT_VIOLATION ) );

		$repository = $this->newRepository();
		$repository->storeDonation( $donation1 );
		$repository->storeDonation( $donation2 );

		$connection = $this->entityManager->getConnection();
		$result = $connection->executeQuery( "SELECT COUNT(*) FROM donation_moderation_reason " );
		$this->assertSame( 1, $result->fetchOne() );
	}

	public function testWhenScrubbingDonation_repositoryRemovesDataAndSets(): void {
		$donationId = 3;
		$donation = ValidDonation::newBankTransferDonation( $donationId );
		$donation->markAsExported();
		$repository = $this->newRepository();
		$repository->storeDonation( $donation );
		$this->entityManager->clear();

		$donation->scrubPersonalData();
		$repository->storeDonation( $donation );

		$connection = $this->entityManager->getConnection();
		$row = $connection->executeQuery( "SELECT * FROM spenden WHERE id=$donationId" )->fetchAssociative();
		$this->assertIsArray( $row );
		$this->assertSame( 1, $row['is_scrubbed'], 'Donation scrub status should be true' );
		$this->assertSame( '', $row['name'] );
		$this->assertSame( '', $row['ort'] );
		$this->assertSame( '', $row['email'] );
		$this->assertSame( '', $row['ueb_code'] );
		// @phpstan-ignore argument.type
		$data = unserialize( base64_decode( $row['data'] ) );
		$this->assertIsArray( $data );
		$this->assertArrayNotHasKey( 'titel', $data );
		$this->assertArrayNotHasKey( 'vorname', $data );
		$this->assertArrayNotHasKey( 'nachname', $data );
		$this->assertArrayNotHasKey( 'email', $data );
		$this->assertArrayNotHasKey( 'strasse', $data );
		$this->assertArrayNotHasKey( 'plz', $data );
		$this->assertArrayNotHasKey( 'ort', $data );
		$this->assertArrayNotHasKey( 'phone', $data );
		$this->assertArrayNotHasKey( 'bankname', $data );
		$this->assertArrayNotHasKey( 'iban', $data );
		$this->assertArrayNotHasKey( 'bic', $data );
		$this->assertArrayNotHasKey( 'blz', $data );
		$this->assertArrayNotHasKey( 'konto', $data );
		$this->assertArrayNotHasKey( 'paypal_first_name', $data );
		$this->assertArrayNotHasKey( 'paypal_last_name', $data );
		$this->assertArrayNotHasKey( 'paypal_address_name', $data );
	}

	private function newEntityManagerThatThrowsOnFind(): EntityManager {
		$stub = $this->createStub( EntityManager::class );
		$stub->method( 'find' )
			->willThrowException( new class() extends \RuntimeException implements ORMException {
			} );
		return $stub;
	}

	private function newEntityManagerThatThrowsOnPersist(): EntityManager {
		$stub = $this->createStub( EntityManager::class );
		$stub->method( 'persist' )
			->willThrowException( new class() extends \RuntimeException implements ORMException {
			} );
		return $stub;
	}
}
